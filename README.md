# Shipment Email Merger

## Описание проекта

**Shipment Email Merger** — это веб-приложение для автоматической обработки и анализа электронной почты, связанной с грузоперевозками. Система автоматически синхронизирует письма из почтовых ящиков пользователей, группирует их по идентификаторам грузов, извлекает структурированную информацию с помощью искусственного интеллекта и предоставляет удобный интерфейс для управления данными о грузах.

### Основные возможности

- **Автоматическая синхронизация почты** через IMAP протокол с поддержкой Gmail и Mail.ru
- **Интеллектуальная группировка писем** по идентификаторам грузов с использованием fuzzy matching
- **AI-анализ содержимого** для автоматического извлечения структурированных данных о грузах
- **Управление статусами групп** для организации рабочего процесса
- **Работа с вложениями** — просмотр и загрузка файлов из писем
- **Автоматическая фоновая синхронизация** по расписанию
- **Инкрементальная обработка** — сохранение только новых писем при повторной синхронизации

### Архитектура

Система построена на микросервисной архитектуре и состоит из трех основных компонентов:

- **Backend API** — сервис обработки почты, группировки писем и управления данными
- **Frontend** — веб-интерфейс на Next.js для взаимодействия пользователя с системой
- **Summary API** — REST API для получения approved summary

Все компоненты работают в Docker-контейнерах и используют PostgreSQL в качестве основной базы данных.

**Деплой:**
- Frontend развернут на Vercel
- Backend и Summary API развернуты на Railway
- Подробная инструкция по деплою доступна в файле `Deployment.md`

## Технологический стек

### Backend
- **Node.js** с TypeScript для типобезопасности и современного синтаксиса
- **Express.js** — веб-фреймворк для создания RESTful API
- **Sequelize** — ORM для работы с PostgreSQL
- **IMAP** — протокол для работы с почтовыми серверами
- **OAuth 2.0** — безопасная аутентификация через почтовые провайдеры
- **JWT** — внутренняя аутентификация между сервисами

### Frontend
- **Next.js 14** — React-фреймворк с серверным рендерингом
- **TypeScript** — типизированный JavaScript
- **Tailwind CSS** — CSS-фреймворк для стилизации

### База данных
- **PostgreSQL** — реляционная база данных для хранения писем, групп и метаданных

### AI и интеграции
- **Google Gemini API** (gemini-2.5-flash) — AI для анализа содержимого писем и извлечения структурированных данных о грузоперевозках

## Запуск приложения

### Требования

- Docker и Docker Compose установлены на вашей машине
- Настроенные OAuth приложения для Gmail и/или Mail.ru (client_id и client_secret)

### Быстрый старт

1. **Клонируйте репозиторий и перейдите в директорию проекта**

2. **Создайте файлы конфигурации `.env`:**

   Создайте файлы `.env` для каждого сервиса на основе шаблонов:
   - `shipment-email-merger/backend/.env`
   - `summary-api/.env`
   
> **Важно:** Примеры конфигурационных файлов находятся в `.env.template`. Замените значения на ваши реальные данные.

3. **Запустите все сервисы через Docker Compose:**

   ```bash
   docker-compose up --build -d
   ```

   Эта команда автоматически:
   - Соберет Docker-образы для всех сервисов
   - Запустит контейнер с PostgreSQL
   - Запустит Backend API
   - Запустит Frontend приложение
   - Запустит Summary API

4. **Проверьте доступность сервисов:**

   После успешного запуска все сервисы будут доступны по следующим адресам:
   - **Frontend:** [http://localhost:3000](http://localhost:3000)
   - **Backend API:** [http://localhost:3001](http://localhost:3001)
   - **Summary API:** [http://localhost:3002](http://localhost:3002)
   - **PostgreSQL:** `localhost:5432`

5. **Остановка сервисов:**

   Для остановки всех контейнеров выполните:
   ```bash
   docker-compose down
   ```

   Для остановки с удалением volumes (включая данные базы):
   ```bash
   docker-compose down -v
   ```

## Руководство пользователя

### Аутентификация и первый вход

При первом запуске приложения пользователь видит форму авторизации. Система поддерживает два почтовых провайдера:

- **Gmail** (gmail.com)
- **Mail.ru** (mail.ru)

#### Процесс авторизации

1. Пользователь вводит свой email адрес в поле ввода
2. Система автоматически определяет провайдера по домену email (gmail.com или mail.ru)
3. При нажатии кнопки "Sign in with email service" происходит перенаправление на страницу OAuth провайдера
4. Пользователь подтверждает доступ к своему почтовому ящику через интерфейс провайдера
5. После успешной авторизации провайдер возвращает пользователя обратно в приложение с authorization code
6. Backend обменивает authorization code на access token и refresh token
7. Система создает пользовательскую сессию и сохраняет OAuth токены в базе данных
8. Пользователь перенаправляется на главную страницу дашборда

#### Уточнения

Система использует OAuth 2.0 протокол для безопасного доступа к почтовому ящику. Токены хранятся в зашифрованном виде в базе данных PostgreSQL. Сессия пользователя управляется через `SessionManagerService`, который отслеживает время жизни сессии и автоматически очищает просроченные сессии.

### Синхронизация почты

Синхронизация — это основной процесс загрузки писем из почтового ящика пользователя в систему для последующей обработки.

#### Выбор периода синхронизации

Система предоставляет несколько способов выбора периода для синхронизации:

1. **Быстрый выбор (предустановленные периоды):**
   - **Последний день** - синхронизирует письма за последние 24 часа
   - **Последние 7 дней** - загружает письма за неделю
   - **Предыдущий месяц** - синхронизирует письма за прошлый календарный месяц
   - **Текущий месяц** - загружает все письма с начала текущего месяца

2. **Кастомный период через календарь:**
   - Пользователь может выбрать произвольный диапазон дат через календарный интерфейс
   - Поддерживается выбор как начальной, так и конечной даты
   - Полезно для синхронизации старых писем или конкретных периодов

3. **Синхронизация без указания периода:**
   - Если период не указан, система использует значения по умолчанию (последний день)

#### Процесс синхронизации

1. **Подключение к почтовому серверу:**
   - Система устанавливает IMAP соединение с почтовым сервером используя XOAUTH2 аутентификацию
   - Соединение создается через `EmailFetcherService`, который управляет жизненным циклом IMAP подключения
   - `EmailConnectionManager` управляет пулом IMAP соединений, переиспользуя их для одного пользователя в рамках сессии
   - При ошибках соединение автоматически пересоздается, система отслеживает активность соединений и закрывает неиспользуемые

2. **Фильтрация писем:**
   - Система выполняет поисковые запросы к почтовому серверу с фильтрацией по дате и содержимому
   - Ищет письма, содержащие идентификаторы групп в теме или теле письма (формат SR-XXXXXX)
   - Применяется фильтрация по дате согласно выбранному периоду через IMAP протокол
   - Исключаются спам-письма на основе черного списка доменов через `isSpamDomain()`
   - Письма загружаются пакетами для оптимизации производительности

3. **Расширенный поиск:**
   - После получения начального набора писем, система извлекает все уникальные идентификаторы групп
   - Для каждого найденного идентификатора выполняется дополнительный поиск всех связанных писем без ограничения по дате
   - Это позволяет найти все исторические письма, относящиеся к найденным группам

4. **Парсинг и обработка:**
   - Каждое письмо парсится с использованием библиотеки `mailparser` для извлечения структурированных данных
   - Извлекаются заголовки: `from`, `to`, `subject`, `date`, `messageId`
   - Парсится тело письма
   - Обрабатываются вложения: извлекается имя файла, тип содержимого (MIME-тип), бинарные данные
   - Вложения загружаются отдельными запросами для каждого письма
   - `EmailParserService` анализирует содержимое и определяет релевантность письма на основе ключевых слов и наличия идентификаторов
   - Извлеченные вложения сохраняются в бинарном формате (BLOB) в базе данных

5. **Группировка писем:**
   - `EmailGrouperService` анализирует все письма и группирует их по идентификаторам групп
   - Из текста письма (тема и тело) извлекаются идентификаторы групп с помощью регулярных выражений, ищущих паттерны типа "SR-123456"
   - Применяется нормализация идентификаторов: приведение к верхнему регистру, стандартизация разделителей (пробелы, дефисы, подчеркивания приводятся к единому формату)
   - Используется fuzzy matching для объединения писем с похожими, но не идентичными идентификаторами (например, "SR-123456" и "SR 123456" будут объединены в одну группу)
   - Письма без идентификаторов обрабатываются отдельно и могут быть привязаны к существующим группам при наличии совпадений
   - В результате создаются объекты групп с уникальным `emailGroupId`, содержащие все связанные письма

6. **Сохранение в базу данных:**
   - Каждая группа писем сохраняется в таблицу `email_groups` с уникальным `emailGroupId` как первичным ключом
   - Письма сохраняются в таблицу `emails` с привязкой к группе через внешний ключ `emailGroupId`
   - Вложения сохраняются в таблицу `attachments` с ссылкой на письмо через внешний ключ `emailId`
   - Используются транзакции базы данных для обеспечения атомарности операций: либо все данные группы (письма и вложения) сохраняются успешно, либо в случае ошибки выполняется откат всех изменений
   - Перед сохранением письма проверяется его существование в базе по уникальному `messageId` для предотвращения дубликатов
   - При сохранении группы проверяется её существование: если группа уже есть, обновляется только список писем, сохраняя существующий AI анализ

7. **AI анализ:**
   - После сохранения группы система проверяет наличие pending summary для группы
   - Если pending summary отсутствует, создается новая summary с уникальным идентификатором, включающим версию (например, `summary_BY-123_v1`, `summary_BY-123_v2`)
   - Версия определяется на основе существующих summary для группы: система находит максимальную версию и создает следующую
   - Все письма группы объединяются в единый контекст
   - Сформированный контекст отправляется в Google Gemini API (модель gemini-2.5-flash) через HTTP запрос с использованием специально разработанного промпта
   - AI модель анализирует содержимое и извлекает структурированную информацию о грузе, преобразуя её в JSON формат согласно заданной схеме
   - При ошибках summary и письма помечаются статусом failed
   - Результат анализа валидируется на наличие полезных данных: если AI не смог извлечь релевантную информацию, статус summary устанавливается в failed
   - Структурированные данные преобразуются в читаемый текст (summary) для удобного просмотра пользователем
   - Результат сохраняется в таблицу `summaries` в поле `shipment_data` со статусом pending (или failed при ошибке)
   - При ручной синхронизации AI анализ запускается автоматически для всех созданных и обновленных групп, которым нужен анализ (группы без summary, с failed summary или с необработанными письмами)

8. **Закрытие соединения:**
   - После завершения синхронизации IMAP соединение корректно закрывается
   - Система освобождает все ресурсы и обновляет статистику последней синхронизации

#### Инкрементальная синхронизация

- **Проверка существования писем:** При повторной синхронизации система проверяет наличие каждого письма в базе данных по уникальному `messageId` (который является первичным ключом в таблице `emails`)
- **Сохранение только новых писем:** Сохраняются только те письма, которые еще не были обработаны и отсутствуют в базе данных
- **Сохранение истории:** Существующие письма не перезаписываются, что позволяет сохранить полную историю изменений и состояние писем на момент их первого получения
- **Автоматическое добавление в группы:** Если в существующей группе появляются новые письма (найденные при повторной синхронизации), они автоматически добавляются к группе через `saveOnlyNewEmails`
- **Обновление метаданных группы:** При добавлении новых писем обновляется поле `updatedAt` группы, но существующий AI анализ (summary) сохраняется и не перезаписывается
- **Обработка вложений:** Новые вложения из новых писем также сохраняются, при этом проверяется уникальность по комбинации `emailId` и `filename` для предотвращения дубликатов

### Работа с группами писем

#### Просмотр списка групп

После синхронизации пользователь видит список всех групп писем на главной странице дашборда. Каждая группа отображает следующую информацию:

- **Идентификатор группы** (например, SR-123456) — уникальный идентификатор, по которому группируются письма
- **Количество писем в группе** — общее число писем, относящихся к данной группе
- **Количество вложений** — суммарное количество файлов, прикрепленных ко всем письмам группы
- **Статус summary** — текущий статус AI анализа группы: `pending` (ожидает обработки), `processing` (обрабатывается), `approved` (подтверждено), `rejected` (отклонено), `failed` (ошибка анализа)
- **Дата последнего обновления** — временная метка последнего изменения группы (добавления новых писем или обновления AI анализа)
- **Индикатор наличия AI анализа** — визуальный индикатор, показывающий наличие завершенного AI анализа для группы

#### Фильтрация и поиск

Система предоставляет инструменты для работы со списком групп:

- **Поиск по идентификатору** — быстрый поиск группы по её ID. При вводе идентификатора система фильтрует список, показывая только группы, содержащие введенный текст в идентификаторе. Если группа с таким идентификатором не найдена в базе, пользователь может выполнить поиск писем по этому идентификатору через функцию "Find by ID", которая подключится к почтовому серверу, найдет все связанные письма и создаст новую группу, если она еще не существует
- **Фильтрация по статусу summary** — отображение только групп с определенным статусом AI анализа: `all` (все группы), `pending` (ожидают обработки), `processing` (обрабатываются), `approved` (подтвержденные), `rejected` (отклоненные), `failed` (с ошибкой анализа)
- **Сортировка** — сортировка списка групп по различным критериям:
  - По дате создания (от новых к старым или наоборот)
  - По идентификатору группы (алфавитно)

#### Просмотр деталей группы

При клике на группу открывается детальная информация в центральной и правой панели интерфейса:

- **Список всех писем группы:**
  - Отображаются все письма, относящиеся к группе, в хронологическом порядке
  - Для каждого письма показывается: отправитель (email адрес), тема письма, дата получения
  - Отображается статус обработки письма: `not_processed` (не обработано), `processing` (обрабатывается), `processed` (обработано), `failed` (ошибка обработки)
  - При клике на письмо можно просмотреть его полное содержимое (текст письма)

- **AI анализ (структурированные данные):**
  - Полная структурированная информация, извлеченная AI из всех писем группы, представленная в формате JSON
  - Основные поля структуры:
    - `name` — ID заказа (только цифры, извлекается из темы письма по паттерну "Shipment #123456")
    - `shipment_details` — массив деталей отправки, каждая содержит:
      - Даты и время отправки (`shipping_date_from`, `shipping_date_to`, `shipping_time_from`, `shipping_time_to`)
      - Даты и время прибытия (`arrival_date_from`, `arrival_date_to`, `arrival_time_from`, `arrival_time_to`)
      - Адрес отправки (`address_from`) с полями: страна, город, почтовый индекс, адрес, даты и время
      - Адрес назначения (`address_dest`) с аналогичными полями
      - Содержимое груза (`contents`) — массив объектов с типом груза (id, название, размеры, количество)
    - `modes` — массив видов перевозки (название, например: "Фура", "Корабль", "Авиаперевозка")
    - `for_carriers` — дополнительная информация для перевозчиков
  - Данные доступны в двух представлениях: текстовом (читаемом) и JSON (для экспорта)

- **Summary (текстовое):**
  - Читаемое текстовое описание груза, автоматически сгенерированное на основе структурированных данных AI анализа
  - Представляет собой человекочитаемую версию всех извлеченных данных в удобном формате
  - Обновляется автоматически при регенерации AI анализа

- **Вложения:**
  - Список всех файлов, прикрепленных к письмам группы, собранный из всех писем
  - Для каждого вложения отображается: имя файла, размер в байтах, тип содержимого (MIME-тип)
  - Вложения организованы по письмам, к которым они относятся, с указанием источника
  - Каждое вложение можно скачать одним кликом

#### Обновление группы (Refresh)

Пользователь может обновить конкретную группу для поиска новых писем:
- При нажатии кнопки "Обновить" система подключается к почтовому серверу
- Выполняется поиск всех писем, содержащих идентификатор выбранной группы
- Найденные новые письма добавляются в группу
- Существующий AI анализ не перезаписывается
- Система предотвращает параллельные обновления одной группы через механизм блокировок

#### Управление статусами summary

Пользователь может изменять статус AI анализа (summary) группы для организации рабочего процесса. Система поддерживает версионирование summary: для одной группы может существовать несколько версий AI анализа с разными статусами. Статус хранится в таблице `summaries`, каждая summary связана с группой через `emailGroupId`:

- **Pending (Ожидает)** — начальный статус новой summary после создания AI анализа, требует проверки пользователем. Группа с таким статусом отображается в списке как требующая внимания
- **Processing (Обрабатывается)** — временный статус, устанавливается во время выполнения AI анализа. Группа показывает индикатор загрузки
- **Approved (Подтверждено)** — summary проверена и одобрена пользователем, готова для использования внешними сервисами через summary API. Только группы со статусом approved доступны через эндпоинт `/api/internal/email-groups/approved`. При изменении статуса на approved система автоматически отправляет уведомления через WebSocket и SSE (Server-Sent Events) для real-time обновлений. Пользователь может переключить rejected summary обратно в approved
- **Rejected (Отклонено)** — summary помечена как нерелевантная или содержащая ошибки. Группа остается в базе, но не используется в рабочих процессах. Пользователь может переключить approved summary обратно в rejected
- **Failed (Ошибка)** — статус устанавливается автоматически при любых ошибках

**Версионирование summary:**
- При создании новой summary система проверяет существующие версии и создает новую с суффиксом версии (например, `summary_BY-123_v1`, `summary_BY-123_v2`)
- При approve/reject pending summary старые approved/rejected summary для этой группы удаляются (кроме текущей)
- Сервис позволяет иметь одновременно только одну pending/processing summary и одну approved/rejected summary для группы

### AI анализ писем

#### Автоматический анализ

При создании новой группы писем система автоматически запускает AI анализ:

1. Все письма группы объединяются в единый контекст: извлекаются темы, тела писем и метаданные (отправитель, получатель, дата). Контекст ограничен 3000 символами для оптимизации запросов к AI
2. Содержимое писем форматируется в специальный промпт и отправляется в Google Gemini API (модель gemini-2.5-flash) через `DeepseekService` с использованием прямых HTTP запросов
3. AI извлекает структурированную информацию о грузе, используя специально разработанный промпт с JSON-схемой
4. Результат анализа преобразуется в JSON структуру `ShipmentRequest` со следующими полями:
   - `name` — ID заказа (только цифры, извлекается из темы письма)
   - `shipment_details` — массив деталей отправки с датами, временем, адресами отправки и назначения, содержимым груза
   - `modes` — массив видов перевозки
   - `for_carriers` — дополнительная информация для перевозчиков (опционально)
5. Структурированные данные валидируются на наличие полезной информации
6. Данные преобразуются в читаемый текст (`summary`) через метод `formatStructuredDataToText`
7. Результат сохраняется в таблицу `summaries` вместе с текстовым `summary` и статусом "pending" (или "failed" при отсутствии полезных данных)

#### Регенерация AI анализа

Если пользователь недоволен результатом анализа или нужно обновить данные:
- Пользователь может нажать кнопку "Regenerate AI" для конкретной группы
- Система повторно отправляет все письма группы в AI сервис
- Старый анализ перезаписывается новым результатом
- Процесс может занять некоторое время, пользователь видит индикатор загрузки

#### Массовая генерация AI summary

Пользователь может запустить генерацию AI summary для всех групп, которым они нужны:
- В интерфейсе доступна кнопка "Sync summaries"
- При нажатии система обрабатывает все группы без summary, с failed summary или с необработанными письмами
- Генерация выполняется последовательно для каждой группы
- Пользователь видит индикатор загрузки во время процесса

#### Просмотр результатов анализа

AI анализ доступен в двух форматах:
- **Текстовый формат** - читаемое описание груза, удобное для быстрого ознакомления
- **JSON формат** - полная структурированная информация в формате JSON, которую можно экспортировать

#### Обработка ошибок AI анализа

При возникновении любых ошибок во время AI анализа система автоматически помечает summary и письма статусом "failed":

**Все типы ошибок обрабатываются единообразно:**
- Любые ошибки (API ошибки, ошибки анализа данных, сетевые ошибки, ошибки парсинга) приводят к установке статуса "failed" для summary и всех писем группы
- Ошибка логируется с указанием кода статуса (если доступен) и сообщения об ошибке
- Пользователь может попробовать регенерировать анализ через кнопку "Regenerate AI" после решения проблемы
- Отображение в интерфейсе: Пользователь видит сообщение о том, что анализ не удался, и группа отображается с соответствующим индикатором статуса
- Визуальная индикация: Письма со статусом failed визуально выделяются в списке для привлечения внимания
- Возможности восстановления: Пользователь может попробовать регенерировать анализ через кнопку "Regenerate AI" или проверить содержимое писем вручную для выявления причин ошибки
- Сохранение данных: Даже при ошибке AI анализа все письма и вложения сохраняются в базе данных, что позволяет вручную просмотреть содержимое

### Работа с вложениями

#### Просмотр вложений

Все вложения из всех писем группы собираются в единый список:
- Отображается имя файла, размер, тип содержимого
- Вложения организованы по письмам, к которым они относятся
- Пользователь может видеть, из какого письма пришло каждое вложение

#### Загрузка вложений

- Пользователь может скачать любое вложение одним кликом через кнопку загрузки рядом с каждым файлом
- Система устанавливает правильные HTTP заголовки (`Content-Type`, `Content-Disposition`) для корректной загрузки файла с сохранением оригинального имени
- Вложения загружаются напрямую из базы данных PostgreSQL, где они хранятся в бинарном формате (BLOB) в таблице `attachments`
- Поддерживаются все типы файлов: документы (PDF, DOC, DOCX), изображения (JPG, PNG), архивы (ZIP, RAR), таблицы (XLS, XLSX) и другие
- При загрузке файл передается потоком для оптимизации использования памяти при работе с большими файлами

### Real-time обновления (WebSocket и SSE)

Система поддерживает real-time обновления для мгновенной передачи информации о подтвержденных summary:

- **WebSocket** (`/ws/approved-summaries`):
  - Используется для связи между Backend и Summary API
  - Summary API подключается к WebSocket серверу backend для получения уведомлений о новых approved summary
  - Автоматическое переподключение при разрыве соединения
  - Кэширование полученных данных в Summary API

- **Server-Sent Events (SSE)** (`/api/email-groups/approved/sse`):
  - Используется для отправки уведомлений клиентам (frontend, внешние системы)
  - Клиенты подключаются через HTTP GET запрос с `sessionId` в query параметре
  - При изменении статуса summary на `approved` все подключенные клиенты получают событие `approved_summary` с данными о грузе
  - Поддержка множественных подключений одновременно

**Процесс работы:**
1. Пользователь подтверждает summary (меняет статус на `approved`)
2. Backend отправляет уведомление через WebSocket в Summary API
3. Backend отправляет уведомление через SSE всем подключенным клиентам
4. Summary API кэширует данные для быстрого доступа
5. Клиенты получают real-time обновление без необходимости обновления страницы

### Автоматическая синхронизация

Система поддерживает автоматическую фоновую синхронизацию почты:

- **Расписание:** По умолчанию автоматическая синхронизация запускается ежедневно в 08:00
- **Процесс:** Система автоматически синхронизирует почту для всех активных пользователей
- **Период:** Автосинхронизация загружает письма за последний день
- **Статус:** Пользователь может видеть время последней автоматической синхронизации на дашборде

#### Технические детали автоматической синхронизации

- `EmailAutoSyncService` управляет расписанием через `setTimeout` с расчетом времени до следующей синхронизации
- Для каждого активного пользователя создается отдельное IMAP соединение
- После синхронизации соединение корректно закрывается
- После успешной синхронизации автоматически запускается `generateSummariesForNeedingGroups()` для генерации AI summary для всех групп, которым они нужны
- Ошибки синхронизации логируются, но не прерывают процесс для других пользователей
- Время последней синхронизации обновляется в базе данных

### Управление сессией

#### Выход из системы

Пользователь может выйти из системы в любой момент:
- При выходе система завершает пользовательскую сессию
- Закрывается IMAP соединение с почтовым сервером
- Учетные данные пользователя деактивируются (но не удаляются для возможности повторного входа)
- Пользователь перенаправляется на страницу авторизации

#### Автоматическое завершение сессии

- **Время жизни сессии:** Сессии имеют ограниченное время жизни (TTL), которое настраивается при создании сессии через `SessionManagerService`
- **Автоматический разлогин:** При истечении срока действия сессии пользователь автоматически разлогинивается при следующем запросе к защищенному эндпоинту
- **Проверка валидности:** Каждый запрос, требующий аутентификации, проверяет валидность сессии через middleware `requireAuth`, который валидирует `sessionId` и обновляет время последней активности
- **Очистка ресурсов:** Система периодически запускает `cleanupExpiredSessions()` для очистки просроченных сессий, что освобождает память и закрывает связанные IMAP соединения
- **Обновление активности:** При каждом успешном запросе время последней активности сессии обновляется, продлевая её срок действия

## Модели базы данных

Система использует реляционную базу данных PostgreSQL с пятью таблицами, связанными через внешние ключи.

### Таблица `users`

Хранит информацию о пользователях системы и их OAuth учетных данных.

**Поля:**
- `id` (INTEGER, PRIMARY KEY, AUTO_INCREMENT) — уникальный идентификатор пользователя
- `email` (STRING, UNIQUE, NOT NULL) — email адрес пользователя, используется для идентификации и определения OAuth провайдера
- `accessToken` (TEXT, NOT NULL) — OAuth access token для доступа к почтовому API провайдера
- `refreshToken` (TEXT, NULLABLE) — OAuth refresh token для обновления access token при истечении срока действия
- `lastSync` (DATE, NOT NULL, DEFAULT NOW) — временная метка последней успешной синхронизации почты
- `isActive` (BOOLEAN, NOT NULL, DEFAULT true) — флаг активности пользователя в системе, используется для автоматической синхронизации
- `createdAt` (DATE, NOT NULL) — временная метка создания записи
- `updatedAt` (DATE, NOT NULL) — временная метка последнего обновления записи

**Индексы:**
- Уникальный индекс на поле `email` для быстрого поиска пользователя
- Индекс на поле `lastSync` для оптимизации запросов при автоматической синхронизации

**Связи:**
- Один пользователь может иметь множество групп писем (связь один-ко-многим с таблицей `email_groups`)

### Таблица `email_groups`

Хранит информацию о группах связанных писем, сгруппированных по идентификаторам грузов.

**Поля:**
- `emailGroupId` (STRING, PRIMARY KEY, NOT NULL) — уникальный идентификатор группы в формате "SR-123456", используется как первичный ключ
- `userId` (INTEGER, NOT NULL, FOREIGN KEY -> users.id) — идентификатор пользователя-владельца группы
- `createdAt` (DATE, NOT NULL, DEFAULT NOW) — временная метка создания группы
- `updatedAt` (DATE, NOT NULL, DEFAULT NOW) — временная метка последнего обновления группы (обновляется при добавлении новых писем)

**Связи:**
- Одна группа может иметь множество summary через `emailGroupId` (связь один-ко-многим с таблицей `summaries`, ON DELETE CASCADE)
- Одна группа принадлежит одному пользователю через `userId` (связь многие-к-одному с таблицей `users`, ON DELETE SET NULL)
- Одна группа содержит множество писем (связь один-ко-многим с таблицей `emails`, ON DELETE CASCADE)

### Таблица `emails`

Хранит информацию об отдельных письмах, связанных с группами.

**Поля:**
- `id` (STRING, PRIMARY KEY, NOT NULL) — уникальный идентификатор письма (messageId из IMAP), используется как первичный ключ
- `from` (STRING, NOT NULL) — email адрес отправителя письма
- `to` (STRING, NOT NULL) — email адрес получателя письма
- `subject` (TEXT, NOT NULL) — тема письма
- `date` (DATE, NOT NULL) — дата получения письма
- `emailGroupId` (STRING, NOT NULL, FOREIGN KEY -> email_groups.emailGroupId) — идентификатор группы, к которой относится письмо
- `status` (ENUM, NOT NULL, DEFAULT 'not_processed') — статус обработки письма: `not_processed` (не обработано), `processing` (обрабатывается), `processed` (обработано), `failed` (ошибка обработки)
- `text` (TEXT('long')) — текстовое содержимое тела письма

**Индексы:**
- Индекс на поле `date` для сортировки и фильтрации по дате
- Индекс на поле `status` для фильтрации по статусу обработки
- Индекс на поле `emailGroupId` для быстрого поиска всех писем группы

**Связи:**
- Одно письмо принадлежит одной группе через `emailGroupId` (связь многие-к-одному с таблицей `email_groups`, ON DELETE CASCADE — при удалении группы удаляются все письма)
- Одно письмо может иметь множество вложений (связь один-ко-многим с таблицей `attachments`, ON DELETE CASCADE)

### Таблица `attachments`

Хранит вложения писем в бинарном формате.

**Поля:**
- `id` (STRING, PRIMARY KEY, NOT NULL) — уникальный идентификатор вложения
- `emailId` (STRING, NOT NULL, FOREIGN KEY -> emails.id) — идентификатор письма, к которому прикреплено вложение
- `filename` (STRING, NOT NULL) — оригинальное имя файла вложения
- `content` (BLOB('long'), NULLABLE) — бинарное содержимое файла, хранится в формате BLOB для поддержки файлов любого размера
- `contentType` (STRING, NULLABLE) — MIME-тип содержимого файла (например, "application/pdf", "image/jpeg")
- `size` (INTEGER, NULLABLE) — размер файла в байтах

**Связи:**
- Одно вложение принадлежит одному письму через `emailId` (связь многие-к-одному с таблицей `emails`, ON DELETE CASCADE — при удалении письма удаляются все его вложения)

### Таблица `summaries`

Хранит результаты AI анализа групп писем в структурированном формате. Поддерживает версионирование: для одной группы может существовать несколько summary с разными версиями и статусами.

**Поля:**
- `summaryId` (STRING, PRIMARY KEY, NOT NULL) — уникальный идентификатор summary с версией (например, `summary_BY-123_v1`, `summary_BY-123_v2`), используется как первичный ключ
- `emailGroupId` (STRING, NOT NULL) — идентификатор группы писем, к которой относится summary
- `shipment_data` (JSONB, NOT NULL) — структурированные данные AI анализа в формате JSON, хранятся в типе JSONB PostgreSQL для эффективного поиска и индексации. Содержит объект типа `ShipmentRequest` с полями: `name` (ID заказа), `shipment_details` (массив с адресами, датами, содержимым), `modes` (массив видов перевозки), `for_carriers` (дополнительная информация перевозчику)
- `summary` (TEXT, NULLABLE, DEFAULT '') — текст, автоматически сгенерированный на основе структурированных данных AI анализа для удобного чтения пользователем
- `status` (ENUM, NOT NULL, DEFAULT 'pending') — статус обработки summary: `pending` (ожидает проверки), `processing` (обрабатывается AI), `approved` (подтверждено пользователем), `rejected` (отклонено), `failed` (ошибка анализа)
- `createdAt` (DATE, NOT NULL, DEFAULT NOW) — временная метка создания summary
- `updatedAt` (DATE, NOT NULL, DEFAULT NOW) — временная метка последнего обновления summary

**Индексы:**
- Индекс на поле `summaryId` для быстрого поиска
- Индекс на поле `emailGroupId` для поиска всех summary группы
- Индекс на поле `status` для фильтрации по статусу (особенно для поиска approved summaries)
- Составной индекс на полях `emailGroupId` и `status` для оптимизации запросов по группе и статусу
- Индекс на поле `createdAt` для сортировки по дате создания

**Связи:**
- Один summary принадлежит одной группе через `emailGroupId` (связь многие-к-одному с таблицей `email_groups`, ON DELETE CASCADE — при удалении группы удаляются все связанные summary)

### Диаграмма связей

```
users (1) ──< (N) email_groups (1) ──< (N) emails (1) ──< (N) attachments
                │
                │ (1:N)
                │
                v
            summaries (N)
```

**Описание связей:**
- Один пользователь может иметь множество групп писем
- Одна группа может содержать множество писем
- Одно письмо может иметь множество вложений
- Одна группа может иметь множество summary (версионирование AI анализа)

## Структура проекта
### Конфигурация (config/)
- app.config.ts\
Конфигурация основный параметров приложения:\
port - порт, на котором запускается сервер (3001)\
env - текущее окружение выполнения (development)\
apiToken - токен для внутреннего API между сервисами

- database.config.ts\
Настройки подключения к базе данных PostgreSQL:\
dialect - тип базы данных (postgres)\
host, port, username, password, database - параметры подключения к СУБД\
logging - включение логирования SQL запросов в режиме development

- oauth.config.ts\
Конфигурация OAuth2 провайдеров (gmail, mail.ru):\
private isConfigValid(config) - проверяет валидность конфигурации провайдера\
getProviderConfig(email) - определяет конфигурацию OAuth провайдера на основе домена email пользователя, проверяет наличие обязательных credentials\
generateAuthUrl(email, providerConfig) - создает URL для OAuth авторизации, добавляя client_id, redirect_uri, scope и кодируя email в state параметр\
private addProviderSpecificParams(email, authUrl) - добавляет провайдер-специфичные параметры в OAuth URL, такие как access_type=offline и prompt=consent для Gmail чтобы получить refresh token

- database.init.ts\
Инициализация и управление подключением к базе данных:\
getInstance() - возвращает единственный экземпляр класса Database, реализуя паттерн Singleton для обеспечения единой точки доступа к подключению базы данных\
private constructor() - приватный конструктор инициализирует подключение Sequelize с конфигурацией из database.config, настраивает логирование и инициализирует модели данных\
createDatabaseIfNotExists() - проверяет существование базы данных в PostgreSQL, подключаясь к системной базе 'postgres', и создает новую базу если она отсутствует\
initialize() - выполняет полную инициализацию: создает базу при необходимости, аутентифицирует подключение, синхронизирует модели с опцией alter для автоматического обновления схемы\
getIsInitialized() - возвращает статус инициализации базы данных, позволяя проверять готовность подключения перед выполнением операций\
getSequelize() - предоставляет доступ к экземпляру Sequelize для выполнения запросов к базе данных и операций с моделями

- auto-sync.init.ts\
Инициализация системы автоматической синхронизации почты:\
initialize() - создает и настраивает сервис автоматической синхронизации\
startAutoSync() - запускает ежедневную синхронизацию по расписанию\
getAutoSyncService() - предоставляет доступ к сервису синхронизации

### Модели данных (models/)
- UserModel - модель пользователя:\
email - уникальный email пользователя для идентификации\
accessToken - OAuth access token для доступа к почтовому API\
refreshToken - OAuth refresh token для обновления access token\
lastSync - временная метка последней успешной синхронизации\
isActive - флаг активности пользователя в системе

- EmailModel - модель письма:\
id - уникальный идентификатор письма (messageId)\
from, to, subject, date - основные метаданные письма\
emailGroupId - ссылка на группу писем, к которой относится данное письмо\
isNew - флаг, новое ли письмо\
text, html - текстовое и HTML содержимое тела письма

- AttachmentModel - модель вложения письма:\
id - уникальный идентификатор вложения\
emailId - ссылка на письмо, к которому прикреплено вложение\
filename - оригинальное имя файла вложения\
content - бинарное содержимое файла в формате BLOB\
contentType - MIME-тип содержимого вложения\
size - размер файла вложения в байтах

- EmailGroupModel - модель группы связанных писем:\
emailGroupId - уникальный идентификатор группы в формате BY-123456\
userId - идентификатор пользователя-владельца группы\
createdAt, updatedAt - временные метки создания и последнего обновления\
Связь с Summary: одна группа может иметь множество summary (связь один-ко-многим через emailGroupId)

- SummaryModel - модель AI анализа группы писем:\
summaryId - уникальный идентификатор summary с версией (например, summary_BY-123_v1)\
emailGroupId - идентификатор группы, к которой относится summary\
shipment_data - структурированные данные AI анализа в формате JSONB (тип ShipmentRequest)\
summary - текстовое описание груза, сгенерированное системой\
status - текущий статус summary (pending/processing/approved/rejected/failed)\
createdAt, updatedAt - временные метки создания и последнего обновления

5. Real-time сервисы (websocket/, sse/)\
- WebSocketService - WebSocket сервер для связи с Summary API:\
initialize() - инициализирует WebSocket сервер на пути /ws/approved-summaries\
sendApprovedSummary() - отправляет уведомления о новых approved summary всем подключенным клиентам\
getConnectedClientsCount() - возвращает количество подключенных клиентов\
- SSEService - Server-Sent Events для отправки уведомлений клиентам:\
addClient() - добавляет клиента в список подписчиков\
removeClient() - удаляет клиента из списка\
sendApprovedSummary() - отправляет уведомления о новых approved summary всем подключенным клиентам через SSE

### Контроллеры (controllers/)
- OAuthController\
Управление процессом OAuth аутентификации:\
getAuthUrl - генерирует URL для перенаправления пользователя к OAuth провайдеру. Извлекает конфигурацию провайдера на основе домена email, добавляет необходимые параметры и state для безопасности.\
handleCallback - обрабатывает callback от OAuth провайдера после авторизации. Обменивает authorization code на access token, получает информацию о пользователе, создает сессию и возвращает данные для клиента.\
getUser - предоставляет информацию о текущем аутентифицированном пользователе. Проверяет валидность сессии и возвращает основные данные пользователя.\
logout - завершает текущую пользовательскую сессию. Удаляет сессию из системы, отключает email сервис и деактивирует учетные данные.

- EmailController\
Управление операциями с почтой:\
getEmailGroups - выполняет полную синхронизацию писем за указанный период. Подключается к почтовому серверу, загружает письма, группирует их по идентификаторам и сохраняет в базу данных с AI анализом.\
findEmailsByEmailGroupId - осуществляет целевой поиск писем по конкретному идентификатору группы. Ищет все письма связанные с указанным emailGroupId и синхронизирует их с базой данных.\
refreshEmailGroup - обновляет данные конкретной группы писем. Проверяет наличие новых писем в группе и добавляет их в базу данных, сохраняя при этом существующий AI анализ.\
getAllEmailGroups - возвращает все группы писем из базы данных. Включает полную информацию о письмах и вложениях, а также статистику по группам.\
getUpdatedEmailGroup - предоставляет актуальные данные конкретной группы после обновления. Загружает свежие данные из базы включая все связанные письма и вложения.\
approveEmailGroupSummary - отмечает письмо как просмотренное и подтвержденное пользователем. Изменяет статус isNew на false и обновляет статистику просмотров.\
getEmailAnalysis - возвращает результат AI анализа для конкретного письма. Извлекает структурированные данные, сгенерированные AI моделью на основе содержимого письма.\
getPendingAnalysis - предоставляет список писем, требующих анализа пользователем. Возвращает все письма с флагом isNew true для последующего просмотра и подтверждения.

- EmailGroupController\
Управление группами писем и связанными операциями:\
getEmailGroups - возвращает полный список всех групп писем с детальной статистикой. Включает информацию о количестве писем, вложениях и статусах групп.\
getApprovedEmailGroups - предоставляет только подтвержденные группы писем. Фильтрует группы по статусу approved и возвращает их в порядке последнего обновления.\
generateAllSummaries - запускает массовую генерацию AI summary для всех групп, которым они нужны (группы без summary, с failed summary или с необработанными письмами). Возвращает статистику обработанных групп.\
regenerateEmailGroupAI - перегенерирует AI анализ для указанной группы писем. Отправляет все письма группы в AI модель для создания новой структурированной информации.\
downloadAttachment - обеспечивает загрузку файла вложения из группы писем. Находит вложение по имени файла и emailGroupId, устанавливает правильные HTTP заголовки и отправляет содержимое.\
getAttachmentInfo - возвращает метаинформацию о всех вложениях в группе писем. Предоставляет список файлов с их размерами и типами без загрузки содержимого.\
approveEmailGroup - изменяет статус группы на "подтверждено". Отмечает группу как проверенную.\
rejectEmailGroup - изменяет статус группы на "отклонено". Помечает группу как нерелевантную.\
deleteEmailGroupSummary - удаляет AI анализ группы без удаления самих писем. Сбрасывает структурированные данные, оставляя возможность для повторного анализа.\
deleteEmailGroup - удаляет указанную группу писем вместе со всеми связанными данными (письма, вложения, summary).

- AutoSyncController\
Управление автоматической синхронизацией почты:\
getAutoSyncStatus - предоставляет текущий статус автоматической синхронизации. Возвращает информацию о времени последней синхронизации, расписании и состоянии сервиса.

### Сервисы (services/)
1. Сервисы аутентификации (auth/)
- AuthService - основной сервис управления аутентификацией:\
handleCallback() - обрабатывает OAuth callback: получает данные пользователя, создает email соединение и сессию\
validateSession() - проверяет валидность сессии по sessionId и обновляет время активности\
getEmailService() - предоставляет email сервис для аутентифицированной сессии с проверкой соединения\
logout() - завершает сессию: отключает email сервис, удаляет сессию и деактивирует учетные данные\
refreshEmailService() - обновляет email соединение при потере связи или истечении токена

- SessionManagerService - управление пользовательскими сессиями:\
createSession() - создает новую сессию с указанным TTL, связывает с email сервисом и пользователем\
validateSession() - проверяет существование и срок действия сессии, обновляет время последней активности\
getEmailService() - возвращает email сервис ассоциированный с сессией с проверкой активности соединения\
logout() - завершает указанную сессию и освобождает связанные ресурсы\
cleanupExpiredSessions() - периодически очищает просроченные сессии для освобождения ресурсов

- CredentialsStorageService - безопасное хранение OAuth учетных данных:\
saveCredentials() - сохраняет OAuth токены пользователя в базу данных с шифрованием конфиденциальных данных\
getAllActiveCredentials() - возвращает список всех активных пользователей для автоматической синхронизации\
updateAccessToken() - обновляет access token пользователя при его смене или обновлении\
deactivateCredentials() - помечает учетные данные как неактивные при выходе или ошибках аутентификации\
getCredentialsByEmail() - извлекает учетные данные пользователя по email для восстановления соединения

- AuthUrlService - генерация URL для OAuth авторизации:\
generateAuthUrl() - создает корректный OAuth URL на основе провайдера email: добавляет client_id, redirect_uri, scope и параметры безопасности\
AuthValidationService - валидация входных данных аутентификации:\
isValidCode() - проверяет формат и длину authorization code от OAuth провайдера\
resolveEmail() - извлекает email пользователя из state параметра или тела запроса callback

2. Сервисы работы с почтой (email/)
- EmailFetcherService - низкоуровневый сервис работы с IMAP:\
connect() - устанавливает безопасное IMAP соединение с почтовым сервером используя XOAUTH2 аутентификацию\
fetchEmailsFilteredByEmailGroupId() - загружает письма за указанный период с фильтрацией по наличию идентификаторов групп в теме\
fetchEmailsByEmailGroupId() - выполняет поиск всех писем содержащих указанный emailGroupId без ограничений по дате\
disconnect() - корректно закрывает IMAP соединение и освобождает ресурсы\
isActive() - проверяет состояние IMAP соединения и возможность выполнения операций

- EmailProcessorService - координация процесса обработки писем:\
getGroupedEmailGroups() - управляет полным циклом обработки: загрузка писем, парсинг, группировка и возврат структурированных данных\
getGroupedEmailGroupsByEmailGroupId() - выполняет целевой поиск и обработку писем для конкретной группы

- EmailParserService - парсинг и анализ содержимого писем:\
parseEmail() - разбирает структуру письма: извлекает заголовки, тело, вложения и идентифицирует emailGroupId\
isRelevantEmail() - определяет релевантность письма для системы на основе ключевых слов и наличия идентификаторов\
isSpamEmail() - идентифицирует спам письма по домену отправителя и содержанию для исключения из обработки

- EmailGrouperService - интеллектуальная группировка писем:\
groupEmailsByEmailGroup() - анализирует письма и группирует их по извлеченным идентификаторам, применяя нормализацию и fuzzy matching\
extractEmailGroupIdFromContent() - извлекает идентификаторы групп из темы и тела письма используя регулярные выражения

- EmailBaseService - базовые операции с письмами и группами:\
saveEmailGroupPreservingAI() - сохраняет группу писем сохраняя существующий AI анализ при обновлении\
saveOnlyNewEmails() - добавляет только новые письма в группу, пропуская уже существующие в базе\
getAllEmailGroupsWithEmails() - загружает все группы с полной информацией о письмах и вложениях

- EmailFullSyncService - управление полной синхронизацией:\
syncAllEmails() - выполняет полную синхронизацию писем за указанный период: загрузка, группировка, сохранение и AI анализ\
syncRecentEmails() - синхронизирует письма за последние N дней для инкрементального обновления

- EmailTargetedService - целевые операции с группами:\
findAndSyncEmailsByGroupId() - находит и синхронизирует все письма для конкретного emailGroupId включая исторические\
processEmailGroup() - обрабатывает группу писем, получает summaryId из текущей pending summary если она существует

- EmailAnalysisService - управление анализом писем:\
approveEmail() - отмечает письмо как просмотренное и обновляет статистику анализа\
getEmailAnalysis() - предоставляет результат AI анализа для конкретного письма\
getPendingAnalysis() - возвращает список непросмотренных писем требующих внимания пользователя

- EmailViewService - управление состоянием просмотра:\
handlePostSyncState() - обрабатывает состояние системы после синхронизации: идентифицирует новые письма\
markAsViewed() - изменяет статус письма на "просмотрено" в базе данных\
getEmailStats() - рассчитывает статистику по письмам: общее количество, просмотренные, ожидающие анализа

- EmailAutoSyncService - автоматическая фоновая синхронизация:\
startAutoSync() - запускает ежедневную автоматическую синхронизацию по расписанию\
executeAutoSync() - выполняет синхронизацию для всех активных пользователей, после чего автоматически запускает генерацию AI summary для групп, которым они нужны\
syncSingleUser() - синхронизирует почту для одного пользователя и запускает генерацию summary при наличии новых или обновленных групп\
generateSummariesForUser() - генерирует AI summary для всех групп пользователя, которым они нужны\
stopAutoSync() - останавливает автоматическую синхронизацию и очищает таймеры\
updateScheduleTime() - изменяет расписание автоматической синхронизации\
getLastSyncTime() - возвращает время последней автосинхронизации\
getFormattedLastSyncTime() - возвращает отформатированное время последней синхронизации

- EmailConnectionManager - управление пулом соединений:\
getConnection() - предоставляет переиспользуемое IMAP соединение для пользователя\
cleanupConnection() - закрывает и очищает соединение при ошибках или logout\
refreshConnection() - обновляет соединение при изменении токенов или потере связи

3. Сервисы групп писем (email-group/)
- EmailGroupManagementService - управление группами писем:\
getAllEmailGroups() - возвращает все группы писем с детальной статистикой по количеству писем и вложений\
getApprovedEmailGroups() - предоставляет только группы с approved summary для использования внешними системами через Summary API\
deleteAllEmailGroups() - полностью очищает базу данных от всех групп, писем, вложений и summary\
deleteEmailGroupSummary() - удаляет pending/processing summary группы, оставляя основные данные писем\
approveEmailGroup() - изменяет статус summary на "approved", позволяет переключить rejected summary обратно в approved, удаляет старые approved/rejected summary (кроме текущей)\
rejectEmailGroup() - изменяет статус summary на "rejected", позволяет переключить approved summary обратно в rejected, удаляет старые approved/rejected summary (кроме текущей)

- AttachmentService - работа с вложениями писем:\
downloadAttachment() - обеспечивает загрузку файла вложения с правильными HTTP заголовками и кэшированием\
getAttachmentInfo() - предоставляет метаинформацию о вложениях без загрузки бинарного содержимого

4. AI сервисы (ai/)
- GeminiService - интеграция с Google Gemini API для анализа контента:\
generateStructuredEmailGroupData() - отправляет содержимое писем в Google Gemini API (модель gemini-2.5-flash) через прямые HTTP запросы с API ключом в заголовках и получает структурированные данные о грузе. Обрабатывает ошибки API (404, 403, 400, 5xx) отдельно от ошибок анализа данных\
createAnalysisPrompt() - создает детальный промпт для AI с инструкциями по извлечению данных из писем, включая обработку ISO 8601 форматов дат и времени. ID заказа извлекается только из темы письма\
formatStructuredDataToText() - преобразует структурированные AI данные в читаемый текстовый формат, извлекая все поля включая адреса, даты, время, содержимое груза\
isMeaningfulAnalysis() - валидирует наличие полезных данных в результате AI анализа

- AiAnalysisService - координация AI анализа:\
processSingleEmailGroup() - выполняет полный AI анализ для одной группы писем: проверяет наличие pending/processing summary, создает новую версию при необходимости, обрабатывает все ошибки единообразно (помечает summary и письма как failed), сохраняет результат\
processAllPendingSummaries() - применяет AI анализ ко всем группам с pending/processing summary\
generateSummariesForNeedingGroups() - генерирует AI summary для всех групп, которым они нужны: группы без summary, с failed summary или с необработанными письмами (статус not_processed)

### Репозитории (repositories/)
- UserRepository - работа с данными пользователей:\
saveUser() - сохраняет или обновляет данные пользователя используя upsert операцию\
getUserByEmail() - находит пользователя по email адресу для аутентификации и поиска\
getAllActiveUsers() - возвращает список всех активных пользователей для автоматической синхронизации\
updateAccessToken() - обновляет OAuth access token пользователя при его изменении\
deactivateUser() - деактивирует пользователя при выходе из системы или ошибках аутентификации

- EmailGroupRepository - работа с группами писем:\
getAllEmailGroups() - загружает все группы писем с включением связанных писем, вложений и summary\
getEmailGroupByEmailGroupId() - находит конкретную группу по идентификатору с полной информацией включая все summary\
saveEmailGroup() - сохраняет или обновляет группу писем сохраняя существующие данные и временные метки\
updateEmailStatusForGroup() - изменяет статус всех писем группы (not_processed/processing/processed/failed)\
getApprovedEmailGroups() - возвращает только группы с approved summary для экспорта и внешнего использования через summary API\
deleteAllEmailGroups() - удаляет все группы писем из базы данных с каскадным удалением связанных записей\
mapToIEmailGroup() - преобразует данные модели в интерфейс IEmailGroup

- EmailRepository - работа с электронными письмами:\
saveEmailsWithAttachments() - сохраняет письма вместе с вложениями в транзакции для обеспечения целостности данных\
updateEmailIsNew() - изменяет статус новизны письма при просмотре пользователем\
getNewEmails() - возвращает все непросмотренные письма для анализа и подтверждения\
getAllEmails() - загружает все письма из базы данных с включением вложений и информацией о группах\
getEmailByMessageId() - находит конкретное письмо по его уникальному идентификатору\
getEmailsByEmailGroupId() - возвращает все письма принадлежащие указанной группе

- AttachmentRepository - работа с вложениями писем:\
getTotalAttachmentsCount() - подсчитывает общее количество вложений в системе для статистики\
getAttachmentsByShipmentId() - находит все вложения связанные с конкретной группой писем\
getAttachmentByFilename() - ищет конкретное вложение по имени файла в пределах группы писем

- SummaryRepository - работа с AI анализами (summary):\
createSummary() - создает новую summary с указанным summaryId, emailGroupId и статусом\
getSummaryById() - находит summary по summaryId с включением связанной группы\
getApprovedSummaryByEmailGroupId() - находит approved summary для группы\
getPendingSummaryByEmailGroupId() - находит pending summary для группы\
getRejectedSummaryByEmailGroupId() - находит rejected summary для группы\
getActiveSummaryByEmailGroupId() - находит активную summary
getSummariesByEmailGroupId() - возвращает все summary для группы (для версионирования)\
updateSummaryStatus() - изменяет статус summary\
updateSummaryAnalysis() - обновляет AI анализ и текстовый summary\
markSummaryAsProcessing() - устанавливает статус 'processing'\
markSummaryAsFailed() - устанавливает статус 'failed'\
deleteOldApprovedRejectedSummaries() - удаляет старые approved/rejected summary для группы (кроме указанной)\
getApprovedSummaries() - возвращает все approved summary с включением групп и писем

### Утилиты (utils/)
- EmailGroupId - работа с идентификаторами групп писем:\
extractEmailGroupIdFromText() - извлекает идентификаторы групп из текста используя регулярные выражения для поиска паттернов BY-123456\
normalizeEmailGroupId() - нормализует формат идентификатора: приводит к верхнему регистру, стандартизирует разделители\
findBestFuzzyMatch() - находит наиболее похожий идентификатор среди существующих используя алгоритмы нечеткого сравнения

- EmailUtilsService - вспомогательные функции для работы с email:\
getAddressText() - форматирует объект адреса email в читаемую строку извлекаю текст или address поле\
convertToIMAPDate() - конвертирует даты в формат требуемый IMAP протоколом для поиска писем\
generateXOAuth2Token() - генерирует XOAUTH2 токен для аутентификации в IMAP используя email и access token\
extractEmailDomain() - извлекает домен из email адреса для определения OAuth провайдера\
isSpamDomain() - проверяет принадлежность домена к списку спам-источников для фильтрации писем

- ValidationUtils - валидация входных данных:\
isValidAuthCode() - проверяет валидность OAuth authorization code по длине и формату\
normalizeAndValidateEmailGroupId() - нормализует и проверяет корректность идентификатора группы писем\
validateRequestBody() - проверяет наличие обязательных полей в теле HTTP запроса\
validateRequestParams() - валидирует обязательные параметры в URL маршруте

- OAuthTokenHandler - обработка OAuth токенов:\
exchangeCodeForTokens() - выполняет OAuth token exchange: отправляет authorization code провайдеру и получает access/refresh tokens

- UserInfo - получение информации о пользователе от OAuth провайдеров:\
getUserInfo() - запрашивает данные пользователя у OAuth провайдера используя access token для аутентификации

- JWTUtils - работа с JWT токенами для внутренней аутентификации:\
verifyInternalToken() - проверяет валидность JWT токена для межсервисных вызовов с проверкой подписи и claims\
isTokenExpired() - определяет истек ли срок действия JWT токена на основе exp claim

- Logger - система логирования приложения:\
info(), error(), warn(), debug() - методы логирования с различными уровнями важности и форматированием вывода

- RequestLogger - логирование HTTP запросов:\
logRequest() - записывает информацию о входящих HTTP запросах: метод, путь, параметры, тело

### Middleware (middleware/)
- auth.middleware - промежуточное ПО для аутентификации пользователей:\
requireAuth() - проверяет аутентификацию пользователя по sessionId, валидирует сессию и обеспечивает доступ к email сервису для обработки запроса\
requireSessionOnly() - упрощенная проверка только валидности сессии без доступа к email сервису для операций не требующих почтовых операций

- internal-auth.middleware - аутентификация для внутренних сервисов:\
requireInternalAuth() - проверяет JWT токены в межсервисных запросах, валидирует подпись и срок действия токена

### Фабрики (factories/)
- ControllerFactory - создание контроллеров с DI:\
createOAuthController() - создает экземпляр OAuthController со всеми зависимостями: AuthService, валидация, URL сервис\
createEmailController() - создает EmailController с полным набором email сервисов, репозиториев и утилит\
createEmailGroupController() - создает EmailGroupController с сервисами управления группами, вложениями и AI анализом

- AutoSyncFactory - создание сервиса автоматической синхронизации почты:\
createEmailAutoSyncService() - создает и конфигурирует экземпляр EmailAutoSyncService со всеми зависимостями, включая репозитории для работы с базой данных, сервисы для обработки почты и хранилище учетных данных пользователей

---

## Summary API

### Описание сервиса

**Summary API** — это отдельный REST API сервис, предназначенный для предоставления внешним системам доступа к структурированным JSON данным (shipment_data) approved AI анализов групп писем. Сервис работает как прокси между внешними клиентами и основным backend API, обеспечивая безопасный доступ только к одобренным структурированным данным о грузах.

### Основные возможности

- **Доступ к approved summary** — предоставляет только структурированные JSON данные (shipment_data) для групп писем с подтвержденным AI анализом
- **JWT аутентификация** — безопасная внутренняя аутентификация с backend API через JWT токены
- **Трансформация данных** — извлекает только `shipment_data` (JSON) из approved групп
- **Health check** — мониторинг работоспособности сервиса и подключения к backend API

### Архитектура Summary API

Summary API построен на Express.js и работает как независимый сервис:

- **Порт:** 3002 (настраивается через `SUMMARY_API_PORT`)
- **Аутентификация:** Использует JWT токены для внутренней аутентификации с backend API
- **Структура:** Разделена на модули: `preload.ts` (загрузка переменных окружения), `app.ts` (конфигурация Express), `server.ts` (запуск сервера)

### Взаимодействие между сервисами

**Процесс запроса:**

1. **Внешний клиент** отправляет HTTP запрос к Summary API по эндпоинту `GET /api/summary/approved`
   - Это публичный эндпоинт Summary API, доступный для внешних систем
   - Summary API работает на порту 3002

2. **Summary API** генерирует JWT токен для внутренней аутентификации с backend API
   - Токен генерируется через `JWTUtils.generateInternalToken('summary-api')`
   - Токен содержит issuer и имеет срок действия
   - Токен кэшируется и автоматически обновляется при приближении истечения срока (за 2 минуты до истечения)

3. **Summary API** отправляет аутентифицированный запрос к backend API
   - Использует `ApiClient` для HTTP запросов
   - Добавляет JWT токен в заголовок `Authorization: Bearer <token>`
   - Запрашивает данные через **внутренний** эндпоинт backend API: `/api/internal/email-groups/approved`
   - **Важно:** `/api/internal/email-groups/approved` — это внутренний эндпоинт backend API, доступный только для внутренних сервисов (Summary API) через JWT аутентификацию. Внешние клиенты не имеют прямого доступа к этому эндпоинту

4. **Backend API** проверяет JWT токен через middleware `requireInternalAuth`
   - Валидирует подпись токена и срок действия
   - Проверяет issuer токена
   - Возвращает только группы со статусом summary = 'approved' со всеми данными (emails, attachments, shipment_data и т.д.)

5. **Summary API** получает данные от backend API и трансформирует их
   - Извлекает только `shipment_data` (структурированные JSON данные) из approved групп
   - Исключает все остальные данные (emails, attachments, userId, статусы и т.д.)
   - Возвращает только `emailGroupId` и `shipment_data` (JSON) для каждой группы

6. **Внешний клиент** получает ответ от Summary API с JSON данными о грузах (shipment_data)

### Конфигурация summary API

**Переменные окружения (.env):**

- `SUMMARY_API_PORT` — порт для запуска сервиса (по умолчанию 3002)
- `MAIN_API_URL` — URL основного backend API (по умолчанию http://localhost:3001, в Docker: http://backend:3001)
- `INTERNAL_API_TOKEN` — токен для внутренней аутентификации (должен совпадать с backend API)
- `JWT_SECRET` — секретный ключ для генерации JWT токенов (должен совпадать с backend API)
- `JWT_ISSUER` — issuer для JWT токенов (должен совпадать с backend API)
- `NODE_ENV` — окружение выполнения (development/production)

**Загрузка переменных окружения:**
- Для локальной разработки используется `.env.development`
- Для Docker/production используется `.env`
- Загрузка происходит автоматически через `preload.ts` при старте сервера

### Безопасность

**JWT аутентификация:**
- Summary API генерирует JWT токены с ограниченным сроком действия
- Токены содержат issuer 'summary-api' для идентификации источника
- Backend API валидирует токены через `requireInternalAuth` middleware
- При ошибке 401 токен сбрасывается и генерируется новый при следующем запросе

**Обработка ошибок:**
- Все ошибки логируются через `logger`
- Ошибки API преобразуются в стандартизированный формат ответа
- Health check позволяет мониторить состояние сервиса

### Проверка работоспособности в Postman

#### 1. Проверка Health Check

**Запрос:**
```
GET http://localhost:3002/api/summary/health
```

**Ожидаемый ответ (200 OK):**
```json
{
  "success": true,
  "data": {
    "service": "summary-api",
    "status": "healthy",
    "mainApi": "connected",
    "timestamp": "2024-01-01T12:00:00.000Z"
  }
}
```

#### 2. Получение всех approved summary

**Запрос:**
```
GET http://localhost:3002/api/summary/approved
```

**Ожидаемый ответ (200 OK):**
```json
{
  "success": true,
  "data": [
    {
      "shipment_data": {
        "name": "123456",
        "shipment_details": [
          {
            "shipping_date_from": "2025-10-15",
            "shipping_date_to": "2025-10-15",
            "shipping_time_from": "09:30",
            "shipping_time_to": "09:30",
            "arrival_date_from": "2025-10-25",
            "arrival_date_to": "2025-10-25",
            "arrival_time_from": "14:00",
            "arrival_time_to": "14:00",
            "address_from": {
              "city": "Минск",
              "address": "ул. Тимирязева, 65",
              "country": "Беларусь"
            },
            "address_dest": {
              "city": "Гродно",
              "address": "ул. Ожешко, 15",
              "country": "Беларусь"
            },
            "contents": [
              {
                "type": {
                  "id": 1,
                  "name": "Электронные компоненты",
                  "width": 40,
                  "height": 30,
                  "length": 25
                },
                "quantity": 1
              }
            ]
          }
        ],
        "modes": [
          {
            "id": 1,
            "name": "Наземная доставка"
          }
        ]
      }
    }
  ],
  "message": "Found 1 approved summaries"
}
```

**Примечание:** API возвращает только `shipment_data` (структурированные JSON данные) для каждой approved группы. Все остальные данные (emailGroupId, emails, attachments, userId, статусы, текстовое summary) исключены из ответа

### Технические детали

**ApiClient:**
- Управляет HTTP запросами к backend API
- Автоматически добавляет JWT токены в заголовки запросов
- Кэширует токены и обновляет их при необходимости (за 2 минуты до истечения)
- Обрабатывает ошибки аутентификации (401) и сбрасывает кэш токенов

**SummaryService:**
- Извлекает только `shipment_data` (структурированные JSON данные) из approved групп, полученных от backend API
- Исключает все остальные данные (emails, attachments, userId, статусы, текстовое summary и т.д.)
- Возвращает только `emailGroupId` и `shipment_data` для каждой группы
- Фильтрует группы без `shipment_data` (группы без данных исключаются)
- Предоставляет health check для мониторинга сервиса и подключения к backend API

**Middleware:**
- `error.middleware` — обработка ошибок